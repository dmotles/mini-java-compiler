import java_cup.runtime.Symbol;
import java.util.*;
import syntaxtree.*;

parser code {:
    public void syntax_error( Symbol cur_token ) {
        String msg  = "Syntax Error at line: " + (cur_token.left+1); 
        msg         += " col: " + (cur_token.right+1) + ".";
        msg         += "\nSymbol: " + cur_token.toString();
        report_error( msg, null );
    }
    public void unrecovered_syntax_error( Symbol cur_token ) throws java.lang.Exception {
        super.unrecovered_syntax_error( cur_token );
    }
:}

terminal PUBLIC;
terminal CLASS;
terminal STATIC;
terminal MAIN;
terminal STRING;
terminal EXTENDS;
terminal RETURN;
terminal TRUE;
terminal FALSE;
terminal INT;
terminal BOOLEAN;
terminal THIS;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal PRINTLN;
terminal SEMICOLON;
terminal COMMA;
terminal EQUALS;
terminal LPAREN;
terminal RPAREN;
terminal LBRACKET;
terminal RBRACKET;
terminal LBRACE;
terminal RBRACE;
terminal BANG;
terminal VOID;
terminal DOT;
terminal LENGTH;
terminal NEW;
terminal AND;
terminal TIMES;
terminal PLUS;
terminal MINUS;
terminal LESSTHAN;
terminal Integer INTLITERAL;
terminal String IDENTIFIER;
//----
/*------------------------------
            Non Terminals
------------------------------*/

non terminal Program program;
non terminal MainClass main_class;
non terminal ClassDeclList class_decl_list;
non terminal ClassDecl class_decl;

non terminal VarDecl var_decl;
non terminal VarDeclList var_decl_list;

non terminal MethodDecl method_decl;
non terminal MethodDeclList method_decl_list;

non terminal FormalList formal_list;
non terminal FormalList formal_rest;

non terminal TypeIdentStruct type_id_pair;

non terminal Statement statement;
non terminal Assign stmt_assign;
non terminal ArrayAssign stmt_array_assign;
non terminal If stmt_if;
non terminal While stmt_while;
non terminal Print stmt_print;
non terminal Block stmt_block;
non terminal StatementList statement_list;

non terminal Exp exp;
non terminal Exp exp_and;
non terminal Exp exp_lt;
non terminal Exp exp_plusminus;
non terminal Exp exp_times;
non terminal Exp exp_not;
non terminal Exp exp_first;
non terminal Exp exp_T;
non terminal ExpList exp_list;
non terminal ExpList exp_rest;

non terminal Identifier ident;

precedence left AND;
precedence left LESSTHAN;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left LBRACKET;

start with program;

program         ::= main_class:m class_decl_list:cl
                    {:  RESULT = new Program( m, cl ); :}
                ;
main_class      ::= CLASS ident:ci LBRACE
                    PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ident:si RPAREN
                    LBRACE statement:s RBRACE RBRACE
                    {: RESULT = new MainClass( ci, si, s ); :}
                ;
class_decl      ::= CLASS ident:ci LBRACE var_decl_list:vdl method_decl_list:mdl RBRACE
                    {: RESULT = new ClassDeclSimple( ci, vdl, mdl ); :}
                |
                CLASS ident:ci EXTENDS ident:ei LBRACE
                var_decl_list:vdl method_decl_list:mdl RBRACE
                    {: RESULT = new ClassDeclExtends( ci, ei, vdl, mdl ); :}
                ;
class_decl_list ::= class_decl_list:cdl class_decl:cd
                    {: cdl.addElement(cd); RESULT = cdl; :}
                |
                    {: RESULT = new ClassDeclList(); :}
                ;
var_decl        ::= type_id_pair:ti SEMICOLON
                    {: RESULT = new VarDecl( ti.type, ti.id ); :}
                ;
var_decl_list   ::= var_decl_list:vdl var_decl:vd
                    {: vdl.addElement(vd); RESULT = vdl; :}
                |
                    {: RESULT = new VarDeclList(); :}
                ;
method_decl     ::= PUBLIC type_id_pair:ti LPAREN formal_list:fl RPAREN
                    LBRACE var_decl_list:vdl statement_list:sl RETURN exp:e SEMICOLON RBRACE
                    {: RESULT = new MethodDecl( ti.type, ti.id, fl, vdl, sl, e ); :}
                ;
method_decl_list ::= method_decl_list:mdl method_decl:md
                    {: mdl.addElement(md); RESULT = mdl; :}
                |
                    {: RESULT = new MethodDeclList(); :}
                ;
formal_list     ::= type_id_pair:ti formal_rest:fl
                    {:
                        FormalList newfl = new FormalList();
                        newfl.addElement( new Formal( ti.type, ti.id ) );
                        for( int i = 0; i < fl.size(); i++) {
                            newfl.addElement( fl.elementAt(i) );
                        }
                        RESULT = newfl;
                    :}
                ;
formal_rest     ::= formal_rest:fl COMMA type_id_pair:ti
                    {: fl.addElement( new Formal( ti.type, ti.id ) ); RESULT = fl; :}
                |
                    {: RESULT = new FormalList(); :}
                ;
type_id_pair    ::= BOOLEAN ident:id
                    {: RESULT = new TypeIdentStruct( new BooleanType(), id ); :}
                |
                    IDENTIFIER:type ident:id
                    {: RESULT = new TypeIdentStruct( new IdentifierType(type), id ); :}
                |
                    INT ident:id
                    {: RESULT = new TypeIdentStruct( new IntegerType(), id ); :}
                |
                    INT LBRACKET RBRACKET ident:id
                    {: RESULT = new TypeIdentStruct( new IntArrayType(), id ); :}
                ;
statement       ::= stmt_block:s
                    {: RESULT = s; :}
                |
                stmt_if:s
                    {: RESULT = s; :}
                |
                stmt_while:s
                    {: RESULT = s; :}
                |
                stmt_print:s
                    {: RESULT = s; :}
                |
                stmt_assign:s
                    {: RESULT = s; :}
                |
                stmt_array_assign:s
                    {: RESULT = s; :}
                ;
stmt_block      ::= LBRACE statement_list:sl RBRACE
                    {: RESULT = new Block( sl ); :}
                ;
stmt_if         ::= IF LPAREN exp:e RPAREN statement:si ELSE statement:se
                    {: RESULT = new If( e, si, se ); :}
                ;
stmt_while      ::= WHILE LPAREN exp:e RPAREN statement:s
                    {: RESULT = new While( e, s ); :}
                ;
stmt_print      ::= PRINTLN LPAREN exp:e RPAREN SEMICOLON
                    {: RESULT = new Print( e ); :}
                ;
stmt_assign     ::= ident:id EQUALS exp:e SEMICOLON
                    {: RESULT = new Assign( id, e ); :}
                ;
stmt_array_assign ::= ident:id LBRACKET exp:ai RBRACKET EQUALS exp:e
                    {: RESULT = new ArrayAssign( id, ai, e ); :}
                ;

statement_list  ::= statement_list:sl statement:s
                    {: sl.addElement( s ); RESULT = sl; :}
                |
                    {: RESULT = new StatementList(); :}
                ;

exp             ::= exp_and:e
                    {: RESULT = e; :}
                ;

exp_and         ::= exp_and:l AND exp_and:r
                    {: RESULT = new And( l, r ); :}
                | exp_lt:e
                    {: RESULT = e; :}
                ;

exp_lt          ::= exp_lt:l LESSTHAN exp_lt:r
                    {: RESULT = new LessThan( l, r ); :}
                | exp_plusminus:e
                    {: RESULT = e; :}
                ;

exp_plusminus   ::= exp_plusminus:l PLUS exp_plusminus:r
                    {: RESULT = new Plus( l , r ); :}
                | exp_plusminus:l MINUS exp_plusminus:r
                    {: RESULT = new Minus( l, r ); :}
                | exp_times:e
                    {: RESULT = e; :}
                ;

exp_times       ::= exp_times:l TIMES exp_times:r
                    {: RESULT = new Times( l, r ); :}
                | exp_not:e
                    {: RESULT = e; :}
                ;

exp_not         ::= BANG exp_not:e
                    {: RESULT = new Not( e ); :}
                | exp_first:e
                    {: RESULT = e; :}
                ;
exp_first       ::= exp_first:object DOT ident:method LPAREN exp_list:args RPAREN
                    {: RESULT = new Call( object, method, args ); :}
                | exp_first:arr DOT LENGTH
                    {: RESULT = new ArrayLength( arr ); :}
                | exp_first:arr LBRACKET exp:e RBRACKET
                    {: RESULT = new ArrayLookup( arr, e ); :}
                | exp_T:e
                    {: RESULT = e; :}
                ;

exp_T           ::= NEW ident:id LPAREN RPAREN
                    {: RESULT = new NewObject( id ); :}
                | NEW INT LBRACKET exp:e RBRACKET
                    {: RESULT = new NewArray( e ); :}
                | INTLITERAL:i
                    {: RESULT = new IntegerLiteral( i.intValue() ); :}
                | IDENTIFIER:s
                    {: RESULT = new IdentifierExp( s ); :}
                | TRUE {: RESULT = new True(); :}
                | FALSE {: RESULT = new False(); :}
                | THIS {: RESULT = new This(); :}
                | LPAREN exp:e RPAREN {: RESULT = e; :}
                ;

exp_list        ::= exp:e exp_rest:er
                    {:
                        ExpList newel = new ExpList();
                        newel.addElement( e );
                        for( int i = 0; i < er.size(); i++) {
                            newel.addElement( er.elementAt(i) );
                        }

                        RESULT = newel;
                    :}
                |
                    {:
                        RESULT = new ExpList();
                    :}
                ;
exp_rest        ::= exp_rest:er COMMA exp:e
                    {: er.addElement(e); RESULT = er; :}
                |
                    {: RESULT = new ExpList(); :}
                ;
ident           ::= IDENTIFIER:s
                {: RESULT = new Identifier(s); :}
                ;
