/**
 * CS1622 Project 3
 * Daniel Motles <dmm141@pitt.edu>
 */
import java_cup.runtime.Symbol;
import java.util.*;
import syntaxtree.*;

parser code {:
    public void syntax_error( Symbol cur_token ) {
        String msg  = "Syntax Error at line: " + (cur_token.left); 
        msg         += " col: " + (cur_token.right) ;
        msg         += " Symbol: " + cur_token.toString();
        msg         += " Parser State: " + cur_token.parse_state;
        report_error( msg, null );
    }
    public void unrecovered_syntax_error( Symbol cur_token ) throws java.lang.Exception {
        super.unrecovered_syntax_error( cur_token );
    }
:}

terminal PUBLIC;
terminal CLASS;
terminal STATIC;
terminal MAIN;
terminal STRING;
terminal EXTENDS;
terminal RETURN;
terminal TRUE;
terminal FALSE;
terminal INT;
terminal BOOLEAN;
terminal THIS;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal PRINTLN;
terminal SEMICOLON;
terminal COMMA;
terminal EQUALS;
terminal LPAREN;
terminal RPAREN;
terminal LBRACKET;
terminal RBRACKET;
terminal LBRACE;
terminal RBRACE;
terminal BANG;
terminal VOID;
terminal DOT;
terminal LENGTH;
terminal NEW;
terminal AND;
terminal TIMES;
terminal PLUS;
terminal MINUS;
terminal LESSTHAN;
terminal Integer INTLITERAL;
terminal String IDENTIFIER;
//----
/*------------------------------
            Non Terminals
------------------------------*/

non terminal Program program;
non terminal MainClass main_class;
non terminal ClassDeclList class_decl_list;
non terminal ClassDecl class_decl;

non terminal VarDecl var_decl;
non terminal VarDeclList var_decl_list;

non terminal MethodDecl method_decl;
non terminal MethodDeclList method_decl_list;

non terminal FormalList formal_list;
non terminal FormalList formal_rest;

non terminal Statement statement;
non terminal StatementList statement_list;

non terminal Exp exp;
non terminal Exp exp_lt;
non terminal Exp exp_plusminus;
non terminal Exp exp_times;
non terminal Exp exp_not;
non terminal Exp exp_first;
non terminal Exp exp_T;
non terminal ExpList exp_list;
non terminal ExpList exp_rest;
non terminal Type type;

non terminal Identifier ident;

precedence left AND;
precedence left LESSTHAN;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left LBRACKET;

start with program;

program         ::= main_class:m class_decl_list:cl
                    {:  RESULT = new Program( m, cl ); :}
                ;
main_class      ::= CLASS:clss ident:ci LBRACE
                    PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ident:si RPAREN
                    LBRACE statement:s RBRACE RBRACE
                    {: RESULT = new MainClass( ci, si, s, clssleft, clssright ); :}
                ;
class_decl      ::= CLASS:clss ident:ci LBRACE var_decl_list:vdl method_decl_list:mdl RBRACE
                    {: RESULT = new ClassDeclSimple( ci, vdl, mdl, clssleft, clssright ); :}
                |
                CLASS:clss ident:ci EXTENDS ident:ei LBRACE
                var_decl_list:vdl method_decl_list:mdl RBRACE
                    {: RESULT = new ClassDeclExtends( ci, ei, vdl, mdl, clssleft, clssright ); :}
                ;
class_decl_list ::= class_decl_list:cdl class_decl:cd
                    {: cdl.addElement(cd); RESULT = cdl; :}
                |
                    {: RESULT = new ClassDeclList(); :}
                ;
var_decl        ::= type:t ident:i SEMICOLON
                    {: RESULT = new VarDecl( t, i, i.line, i.col ); :}
                ;
var_decl_list   ::= var_decl_list:vdl var_decl:vd
                    {:
                        vdl.addElement( vd );
                        RESULT = vdl; 
                    :}
                |
                    {: RESULT = new VarDeclList(); :}
                ;
method_decl     ::= PUBLIC type:t ident:i LPAREN formal_list:fl RPAREN
                    LBRACE var_decl_list:vdl statement_list:sl RETURN exp:e SEMICOLON RBRACE
                    {: RESULT = new MethodDecl( t, i, fl, vdl, sl, e, i.line, i.col ); :}
                ;
method_decl_list ::= method_decl_list:mdl method_decl:md
                    {: mdl.addElement(md); RESULT = mdl; :}
                |
                    {: RESULT = new MethodDeclList(); :}
                ;
formal_list     ::= type:t ident:id formal_rest:fl
                    {:
                        FormalList newfl = new FormalList();
                        newfl.addElement( new Formal( t, id, t.line, t.col ) );
                        for( int i = 0; i < fl.size(); i++) {
                            newfl.addElement( fl.elementAt(i) );
                        }
                        RESULT = newfl;
                    :}
                |
                    {: RESULT = new FormalList(); :}
                ;
formal_rest     ::= formal_rest:fl COMMA type:t ident:i
                    {: fl.addElement( new Formal( t, i, t.line, t.col ) ); RESULT = fl; :}
                |
                    {: RESULT = new FormalList(); :}
                ;

type            ::= BOOLEAN:b
                    {: RESULT = new BooleanType( bleft, bright ); :}
                | IDENTIFIER:type
                    {: RESULT = new IdentifierType( type, typeleft, typeright ); :}
                | INT:i
                    {: RESULT = new IntegerType( ileft, iright ); :}
                | INT:i LBRACKET RBRACKET
                    {: RESULT = new IntArrayType( ileft, iright ); :}
                ;
statement      ::= LBRACE:lbr statement_list:sl RBRACE
                    {: RESULT = new Block( sl, lbrleft, lbrright ); :}
                | IF:i LPAREN exp:e RPAREN statement:si ELSE statement:se
                    {: RESULT = new If( e, si, se, ileft, iright ); :}
                | WHILE:w LPAREN exp:e RPAREN statement:s
                    {: RESULT = new While( e, s, wleft, wright ); :}
                | PRINTLN:p LPAREN exp:e RPAREN SEMICOLON
                    {: RESULT = new Print( e, pleft,pright ); :}
                | ident:id EQUALS exp:e SEMICOLON
                    {: RESULT = new Assign( id, e, id.line, id.col ); :}
                | ident:id LBRACKET exp:ai RBRACKET EQUALS exp:e SEMICOLON
                    {: RESULT = new ArrayAssign( id, ai, e, id.line, id.col ); :}
                ;

statement_list  ::= statement:s statement_list:sl
                    {:  
                        if( sl.size() > 0 ) {
                            StatementList oldsl = sl;
                            sl = new StatementList();
                            sl.addElement( s );
                            for( int i=0; i < oldsl.size(); i++)
                                sl.addElement( oldsl.elementAt(i) );
                        } else {
                            sl.addElement( s );
                        }
                        RESULT = sl;
                    :}
                |
                    {: RESULT = new StatementList(); :}
                ;

exp             ::= exp:l AND:a exp:r
                    {: RESULT = new And( l, r, aleft, aright ); :}
                | exp_lt:e
                    {: RESULT = e; :}
                ;

exp_lt          ::= exp_lt:l LESSTHAN:lt exp_lt:r
                    {: RESULT = new LessThan( l, r, ltleft, ltright ); :}
                | exp_plusminus:e
                    {: RESULT = e; :}
                ;

exp_plusminus   ::= exp_plusminus:l PLUS:p exp_plusminus:r
                    {: RESULT = new Plus( l , r, pleft, pright ); :}
                | exp_plusminus:l MINUS:m exp_plusminus:r
                    {: RESULT = new Minus( l, r, mleft, mright ); :}
                | exp_times:e
                    {: RESULT = e; :}
                ;

exp_times       ::= exp_times:l TIMES:t exp_times:r
                    {: RESULT = new Times( l, r, tleft, tright ); :}
                | exp_not:e
                    {: RESULT = e; :}
                ;

exp_not         ::= BANG:b exp_not:e
                    {: RESULT = new Not( e, bleft, bright ); :}
                | exp_first:e
                    {: RESULT = e; :}
                ;
exp_first       ::= exp_first:object DOT ident:method LPAREN exp_list:args RPAREN
                    {: RESULT = new Call( object, method, args, method.line, method.col ); :}
                | exp_first:arr DOT LENGTH:len
                    {: RESULT = new ArrayLength( arr, lenleft, lenright ); :}
                | exp_first:arr LBRACKET:lb exp:e RBRACKET
                    {: RESULT = new ArrayLookup( arr, e, lbleft, lbright ); :}
                | exp_T:e
                    {: RESULT = e; :}
                ;

exp_T           ::= NEW:n ident:id LPAREN RPAREN
                    {: RESULT = new NewObject( id, nleft, nright ); :}
                | NEW:n INT LBRACKET exp:e RBRACKET
                    {: RESULT = new NewArray( e, nleft, nright ); :}
                | INTLITERAL:i
                    {: RESULT = new IntegerLiteral( i.intValue(), ileft, iright ); :}
                | IDENTIFIER:s
                    {: RESULT = new IdentifierExp( s, sleft, sright ); :}
                | TRUE:e {: RESULT = new True( eleft, eright ); :}
                | FALSE:e {: RESULT = new False( eleft, eright ); :}
                | THIS:e {: RESULT = new This( eleft, eright ); :}
                | LPAREN exp:e RPAREN {: RESULT = e; :}
                ;

exp_list        ::= exp:e exp_rest:er
                    {:
                        ExpList newel = new ExpList();
                        newel.addElement( e );
                        for( int i = 0; i < er.size(); i++) {
                            newel.addElement( er.elementAt(i) );
                        }

                        RESULT = newel;
                    :}
                |
                    {:
                        RESULT = new ExpList();
                    :}
                ;
exp_rest        ::= exp_rest:er COMMA exp:e
                    {: er.addElement(e); RESULT = er; :}
                |
                    {: RESULT = new ExpList(); :}
                ;
ident           ::= IDENTIFIER:s
                {: RESULT = new Identifier(s, sleft, sright ); :}
                ;
